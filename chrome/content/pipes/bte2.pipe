bte.prototype = new pipe();
bte.prototype.Constructor = bte();

function bte()
{
    // 
    // BTE-like pipe (cf. bte). this one however, works on paragraphs rather
    // than on nodes (cf. difference between cl and txt).
    //
}

bte.extract = function(doc)
{
    var res = '';
    var bt = [];
    var bi = [];
    var reps = [];

    // count the tags /between/ the relevant text nodes
    internodes = 0;

    var txind = 0;
    var line = [];

    // returns true for 'interrupting' nodes 
    wsNode = function (node)
    {
        var nn = node.nodeName + "";

        return (nn == "P" ||
            nn == "DIV" ||
            nn == "BR" ||
            nn == "BLOCKQUOTE" ||
            nn == "DL" ||
            nn == "UL" ||
            nn == "OL" ||
            nn == "LI" ||
            nn == "TR" ||
            nn == "TH" ||
            nn == "TD" ||
            nn == "TABLE" ||
            nn == "OPTION" ||
            nn == "PRE" ||
            nn == "H1" ||
            nn == "H2" ||
            nn == "H3" ||
            nn == "H4" ||
            nn == "H5" ||
            nn == "H6");
    };

    function prtLines()
    {
        length=0;
        for (i=0; i < line.length; i++)
        {

            // BTE like features
            // number of non-WS delimited tokens (~= words) in the node's
            // resulting text
            tx = line[i].replace( /^\s+/g, "").replace( /\s+$/g, "").replace( /\n/g, " ")
            length += tx.split(/\s/).length;
        }

        reps[reps.length] = line.length;
        bt[bt.length] = length;
        bi[bi.length] = internodes;

        line = [];
        txind = 0;
        internodes=0;
    };
    

    function rec(node, paren)
    {
        if ((node.nodeName == "#text") &&
            node.data.replace( /^\s+/g, "").replace( /\s+$/g, "")
            .replace( /\n/g, " ").replace(/  +/g, " "))
        {
            // keep the formatting close to the rendered output, e.g.
            // do not discard ' ' between two <A> tags; or else the text of the links sticks together.
            var formttx = node.data.replace( /^\s+/g, "").replace( /\s+$/g, "").replace( /\n/g, " ").replace(/  +/g, " "); 
            line[line.length] = formttx;
        } else if (node.nodeName != "#comment" && node.nodeName != "SCRIPT" && node.nodeName != "KW" && node.nodeName != undefined) {
            internodes++;
        }

        if (line.length > 0 && wsNode(node))
        {
            prtLines();
        }

        // recurse to children
        var nparen = paren.slice();
        if (node.nodeType)
            nparen[nparen.length] = node.nodeType;

        for (child in node.childNodes)
        {
            cnode = node.childNodes[child];
            if (cnode.nodeName != "SCRIPT")
                rec(cnode, nparen);
        }
    };

    rec(doc.QueryInterface(Components.interfaces.nsIDOMNSElement), []);
    if (line.length > 0) prtLines();

    bteres = bte(bt,bi);
    min = bteres.min;
    max = bteres.max;
    verbose("min: "+ min +", max: "+max);
    
    for (i=0; i < bt.length; i++)
    {
        for (j=0; j < reps[i]; j++)
        {
            res += bt[i] + ' ' + bi[i] + ' ';
            if (i < min | i > max)
                res += "-1" + "\n";
            else
                res += "1" + "\n";
        }
    }


    function bte(tokens, internodes)
    {
        // find breakpoints
        var bps = [];

        for (i=0; i < tokens.length; i++)
        {
            bps[bps.length] = tokens[i] - internodes[i];
        }

        // find breakpoints range which maximises the score
        max_score = 0;
        max_start = 0;
        max_end   = 0;
        for (i=0; i < bps.length; i++)
        {
            score = bps[i];
            if (score > max_score)
            {
                max_score = score;
                if (i > 0)
                    max_start = i;
                else     
                    max_start = 0;
                max_end = i;
            }

            for (j=i+1; j < bps.length; j++)
            {
                score+= bps[j];
                if (score > max_score)
                {
                    max_score = score
                    if (i > 0)
                        max_start = i;
                    else
                        max_start = 0;
                    max_end = j;
                }
            }
        }
        return { min: max_start, max: max_end };
    }
    return res;
}


// vim: filetype=javascript
